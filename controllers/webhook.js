'use strict'

const bufferEq = require('buffer-equal-constant-time')
const path = require('path')
const config = require(path.join(__dirname, '/../config'))
const crypto = require('crypto')

const gitFactory = require('../lib/GitServiceFactory')
const Staticman = require('../lib/Staticman')

/**
 * Express handler for webhook requests/notifications generated by the backing git service.
 */
module.exports = async (req, res, next) => {
  // Allow for multiple errors to be raised and reported back.
  let errorsRaised = []
  let event

  let service = req.params.service
  const version = req.params.version
  // v1 of the webhook endpoint assumed GitHub.
  if (service === null || typeof service === 'undefined') {
    if (version === '1') {
      service = 'github'
    }
  }

  const username = req.params.username
  const repository = req.params.repository
  const branch = req.params.branch

  switch (service) {
    case 'github':
      event = req.headers['x-github-event']
      if (!event) {
        errorsRaised.push('No event found in the request')
      } else {
        if (event === 'pull_request') {
          const webhookSecretExpected = config.get('githubWebhookSecret')
          const webhookSecretSent = req.headers['x-hub-signature']

          let reqAuthenticated = true
          if (webhookSecretExpected) {
            reqAuthenticated = false
            if (!webhookSecretSent) {
              // This could be worth logging... unless the endpoint gets hammered with spam.
              errorsRaised.push('No secret found in the webhook request')
            } else if (_verifyGitHubSignature(webhookSecretExpected, JSON.stringify(req.body), webhookSecretSent)) {
              reqAuthenticated = true
            } else {
              // This could be worth logging... unless the endpoint gets hammered with spam.
              errorsRaised.push('Unable to verify authenticity of request')
            }
          }

          if (reqAuthenticated) {
            await _handleMergeRequest(version, service, username, repository, branch, req.body).catch((errors) => {
              errorsRaised = errors
            })
          }
        }
      }

      break
    case 'gitlab':
      event = req.headers['x-gitlab-event']
      if (!event) {
        errorsRaised.push('No event found in the request')
      } else {
        if (event === 'Merge Request Hook') {
          const webhookSecretExpected = config.get('gitlabWebhookSecret')
          const webhookSecretSent = req.headers['x-gitlab-token']

          let reqAuthenticated = true
          if (webhookSecretExpected) {
            reqAuthenticated = false
            if (!webhookSecretSent) {
              // This could be worth logging... unless the endpoint gets hammered with spam.
              errorsRaised.push('No secret found in the webhook request')
            } else if (webhookSecretExpected === webhookSecretSent) {
              /*
               * Whereas GitHub uses the webhook secret to sign the request body, GitLab does not.
               * As such, just check that the received secret equals the expected value.
               */
              reqAuthenticated = true
            } else {
              // This could be worth logging... unless the endpoint gets hammered with spam.
              errorsRaised.push('Unable to verify authenticity of request')
            }
          }

          if (reqAuthenticated) {
            await _handleMergeRequest(version, service, username, repository, branch, req.body).catch((errors) => {
              errorsRaised = errors
            })
          }
        }
      }

      break
    default:
      errorsRaised.push('Unexpected service specified.')
  }

  if (errorsRaised.length > 0) {
    res.status(400).send({
      errors: JSON.stringify(errorsRaised)
    })
  } else {
    res.status(200).send({
      success: true
    })
  }
}

const _verifyGitHubSignature = function (secret, data, signature) {
  const signedData = 'sha1=' + crypto.createHmac('sha1', secret).update(data).digest('hex')
  return bufferEq(Buffer.from(signature), Buffer.from(signedData))
}

const _handleMergeRequest = async function (version, service, username, repository, branch, data) {
  // Allow for multiple errors to be raised and reported back.
  const errors = []

  const ua = config.get('analytics.uaTrackingId')
    ? require('universal-analytics')(config.get('analytics.uaTrackingId'))
    : null

  let gitService = null
  let mergeReqNbr = null
  if (service === 'github') {
    /*
     * In v1 of the endpoint, the service, username, repository, and branch parameters were
     * ommitted. As such, if not provided in the webhook request URL, pull them from the webhook
     * payload.
     */
    if (username === null || typeof username === 'undefined') {
      username = data.repository.owner.login
    }
    if (repository === null || typeof repository === 'undefined') {
      repository = data.repository.name
    }
    if (branch === null || typeof branch === 'undefined') {
      branch = data.pull_request.base.ref
    }

    gitService = await gitFactory.create('github', {
      version: version,
      username: username,
      repository: repository,
      branch: branch
    })
    mergeReqNbr = data.number
  } else if (service === 'gitlab') {
    gitService = await gitFactory.create('gitlab', {
      version: version,
      username: username,
      repository: repository,
      branch: branch
    })
    mergeReqNbr = data.object_attributes.iid
  } else {
    errors.push('Unable to determine service.')
    return Promise.reject(errors)
  }

  if (mergeReqNbr === null || typeof mergeReqNbr === 'undefined') {
    errors.push('No pull/merge request number found.')
    return Promise.reject(errors)
  }

  let review = await gitService.getReview(mergeReqNbr).catch((error) => {
    const msg = `Failed to retrieve merge request ${mergeReqNbr} - ${error}`
    console.error(msg)
    errors.push(msg)
    return Promise.reject(errors)
  })

  /*
   * We might receive "real" (non-bot) pull requests for files other than Staticman-processed
   * comments. Ignore these by filtering on Staticman-created merge request branches.
   */
  if (review.sourceBranch.indexOf('staticman_') > -1) {
    /*
     * Note that the review state is derived from the call to the git service, NOT the webhook
     * payload. And merged requests are represented with different states in each (at least in
     * GitHub). Tricky.
     *
     * We'll regularly receive webhook calls whenever a pull/merge request is opened, not just
     * merged/closed.
     */
    if (review.state === 'merged' || review.state === 'closed') {
      await _createNotifyMailingList(review, ua).catch((error) => {
        errors.push(error.message)
      })

      /*
       * Deleting the merge request branch is only necessary for GitHub, as GitLab automatically
       * deletes it upon merging.
       */
      if (service === 'github') {
        await _deleteMergeRequestBranch(gitService, review, ua).catch((error) => {
          errors.push(error)
        })
      }
    }
  }

  if (errors.length > 0) {
    return Promise.reject(errors)
  }
}

const _createNotifyMailingList = async function (review, ua) {
  /*
   * The "staticman_notification" comment section of the pull/merge request comment only
   * exists if notifications were enabled at the time the pull/merge request was created.
   */
  const bodyMatch = review.body.match(/(?:.*?)<!--staticman_notification:(.+?)-->(?:.*?)/i)
  if (bodyMatch && (bodyMatch.length === 2)) {
    try {
      const parsedBody = JSON.parse(bodyMatch[1])
      const staticman = await new Staticman(parsedBody.parameters)

      staticman.setConfigPath(parsedBody.configPath)

      await staticman.processMerge(parsedBody.fields, parsedBody.extendedFields, parsedBody.options).then(msg => {
        if (ua) {
          ua.event('Hooks', 'Create/notify mailing list').send()
        }
      }).catch(err => {
        return Promise.reject(err)
      })
    } catch (err) {
      if (ua) {
        ua.event('Hooks', 'Create/notify mailing list error').send()
      }

      return Promise.reject(err)
    }
  }
}

const _deleteMergeRequestBranch = async function (gitService, review, ua) {
  try {
    // This will throw the error 'Reference does not exist' if the branch has already been deleted.
    await gitService.deleteBranch(review.sourceBranch)
    if (ua) {
      ua.event('Hooks', 'Delete branch').send()
    }
  } catch (err) {
    if (ua) {
      ua.event('Hooks', 'Delete branch error').send()
    }

    const msg = `Failed to delete merge branch ${review.sourceBranch} - ${err}`
    console.error(msg)
    return Promise.reject(msg)
  }
}
