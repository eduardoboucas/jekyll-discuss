'use strict'

const bufferEq = require('buffer-equal-constant-time')
const path = require('path')
const config = require(path.join(__dirname, '/../config'))
const crypto = require('crypto')

const gitFactory = require('../lib/GitServiceFactory')
const Staticman = require('../lib/Staticman')

/**
 * Express handler for webhook requests/notifications generated by the backing git service.
 */
module.exports = async (req, res, next) => {
  let errorsRaised = []

  let service = req.params.service
  const version = req.params.version

  if (_calcIsVersion1WhenGitHubAssumed(service, version)) {
    service = 'github'
  }

  switch (service) {
    case 'github':
      await _handleWebhookGitHub(req, service, version).catch((errors) => {
        errorsRaised = errorsRaised.concat(errors)
      })
      break
    case 'gitlab':
      await _handleWebhookGitLab(req, service, version).catch((errors) => {
        errorsRaised = errorsRaised.concat(errors)
      })
      break
    default:
      errorsRaised.push('Unexpected service specified.')
  }

  if (errorsRaised.length > 0) {
    res.status(400).send({
      errors: JSON.stringify(errorsRaised)
    })
  } else {
    res.status(200).send({
      success: true
    })
  }
}

const _handleWebhookGitHub = async function (req, service, version) {
  let errorsRaised = []

  const username = req.params.username
  const repository = req.params.repository
  const branch = req.params.branch

  const event = req.headers['x-github-event']
  if (!event) {
    errorsRaised.push('No event found in the request')
  } else {
    if (event === 'pull_request') {
      const webhookSecretExpected = config.get('githubWebhookSecret')
      const webhookSecretSent = req.headers['x-hub-signature']

      let reqAuthenticated = true
      if (webhookSecretExpected) {
        reqAuthenticated = false
        if (!webhookSecretSent) {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('No secret found in the webhook request')
        } else if (_verifyGitHubSignature(webhookSecretExpected, JSON.stringify(req.body), webhookSecretSent)) {
          reqAuthenticated = true
        } else {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('Unable to verify authenticity of request')
        }
      }

      if (reqAuthenticated) {
        await _handleMergeRequest(version, service, username, repository, branch, req.body).catch((errors) => {
          errorsRaised = errors
        })
      }
    }
  }

  if (errorsRaised.length > 0) {
    return Promise.reject(errorsRaised)
  }
}

const _handleWebhookGitLab = async function (req, service, version) {
  let errorsRaised = []

  const username = req.params.username
  const repository = req.params.repository
  const branch = req.params.branch

  const event = req.headers['x-gitlab-event']
  if (!event) {
    errorsRaised.push('No event found in the request')
  } else {
    if (event === 'Merge Request Hook') {
      const webhookSecretExpected = config.get('gitlabWebhookSecret')
      const webhookSecretSent = req.headers['x-gitlab-token']

      let reqAuthenticated = true
      if (webhookSecretExpected) {
        reqAuthenticated = false
        if (!webhookSecretSent) {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('No secret found in the webhook request')
        } else if (webhookSecretExpected === webhookSecretSent) {
          /*
           * Whereas GitHub uses the webhook secret to sign the request body, GitLab does not.
           * As such, just check that the received secret equals the expected value.
           */
          reqAuthenticated = true
        } else {
          // This could be worth logging... unless the endpoint gets hammered with spam.
          errorsRaised.push('Unable to verify authenticity of request')
        }
      }

      if (reqAuthenticated) {
        await _handleMergeRequest(version, service, username, repository, branch, req.body).catch((errors) => {
          errorsRaised = errors
        })
      }
    }
  }

  if (errorsRaised.length > 0) {
    return Promise.reject(errorsRaised)
  }
}

const _calcIsVersion1WhenGitHubAssumed = function (service, version) {
  return (!service && version === '1')
}

const _verifyGitHubSignature = function (secret, data, signature) {
  const signedData = 'sha1=' + crypto.createHmac('sha1', secret).update(data).digest('hex')
  return bufferEq(Buffer.from(signature), Buffer.from(signedData))
}

const _handleMergeRequest = async function (version, service, username, repository, branch, data) {
  const errors = []

  const ua = config.get('analytics.uaTrackingId')
    ? require('universal-analytics')(config.get('analytics.uaTrackingId'))
    : null

  let gitService = null
  let mergeReqNbr = null
  if (service === 'github') {
    gitService = await _buildGitHubService(version, service, username, repository, branch, data)
    mergeReqNbr = data.number
  } else if (service === 'gitlab') {
    gitService = await gitFactory.create('gitlab', {
      version: version,
      username: username,
      repository: repository,
      branch: branch
    })
    mergeReqNbr = data.object_attributes.iid
  } else {
    errors.push('Unable to determine service.')
    return Promise.reject(errors)
  }

  if (mergeReqNbr === null || typeof mergeReqNbr === 'undefined') {
    errors.push('No pull/merge request number found.')
    return Promise.reject(errors)
  }

  let review = await gitService.getReview(mergeReqNbr).catch((error) => {
    const msg = `Failed to retrieve merge request ${mergeReqNbr} - ${error}`
    console.error(msg)
    errors.push(msg)
    return Promise.reject(errors)
  })

  if (_calcIsMergeRequestStaticmanGenerated(review)) {
    if (_calcIsMergeRequestAccepted(review)) {
      await _createNotifyMailingList(review, ua).catch((error) => {
        errors.push(error.message)
      })

      if (_calcIsMergeRequestBranchRequiresManualDelete(service)) {
        await _deleteMergeRequestBranch(gitService, review, ua).catch((error) => {
          errors.push(error)
        })
      }
    }
  }

  if (errors.length > 0) {
    return Promise.reject(errors)
  }
}

const _buildGitHubService = function (version, service, username, repository, branch, data) {
  /*
   * In v1 of the endpoint, the service, username, repository, and branch parameters were
   * ommitted. As such, if not provided in the webhook request URL, pull them from the webhook
   * payload.
   */
  if (username === null || typeof username === 'undefined') {
    username = data.repository.owner.login
  }
  if (repository === null || typeof repository === 'undefined') {
    repository = data.repository.name
  }
  if (branch === null || typeof branch === 'undefined') {
    branch = data.pull_request.base.ref
  }

  return gitFactory.create(service, {
    version: version,
    username: username,
    repository: repository,
    branch: branch
  })
}

const _calcIsMergeRequestAccepted = function (review) {
  return (review.state === 'merged' || review.state === 'closed')
}

const _calcIsMergeRequestStaticmanGenerated = function (review) {
  return (review.sourceBranch.indexOf('staticman_') > -1)
}

const _calcIsMergeRequestBranchRequiresManualDelete = function (service) {
  return (service === 'github')
}

const _createNotifyMailingList = async function (review, ua) {
  const bodyMatch = review.body.match(/(?:.*?)<!--staticman_notification:(.+?)-->(?:.*?)/i)
  if (_calcIsNotificationsEnabledWhenMergeRequestCreated(bodyMatch)) {
    try {
      const parsedBody = JSON.parse(bodyMatch[1])
      const staticman = await new Staticman(parsedBody.parameters)

      staticman.setConfigPath(parsedBody.configPath)

      await staticman.processMerge(parsedBody.fields, parsedBody.extendedFields, parsedBody.options).then(msg => {
        if (ua) {
          ua.event('Hooks', 'Create/notify mailing list').send()
        }
      })
    } catch (err) {
      if (ua) {
        ua.event('Hooks', 'Create/notify mailing list error').send()
      }

      return Promise.reject(err)
    }
  }
}

const _calcIsNotificationsEnabledWhenMergeRequestCreated = function (bodyMatch) {
  return (bodyMatch && (bodyMatch.length === 2))
}

const _deleteMergeRequestBranch = async function (gitService, review, ua) {
  try {
    // This will throw the error 'Reference does not exist' if the branch has already been deleted.
    await gitService.deleteBranch(review.sourceBranch)
    if (ua) {
      ua.event('Hooks', 'Delete branch').send()
    }
  } catch (err) {
    if (ua) {
      ua.event('Hooks', 'Delete branch error').send()
    }

    const msg = `Failed to delete merge branch ${review.sourceBranch} - ${err}`
    console.error(msg)
    return Promise.reject(msg)
  }
}
